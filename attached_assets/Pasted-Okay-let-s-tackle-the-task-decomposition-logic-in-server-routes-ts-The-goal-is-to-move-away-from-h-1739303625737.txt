Okay, let's tackle the task decomposition logic in server/routes.ts. The goal is to move away from hardcoded steps and leverage an AI model (OpenAI, Gemini, etc.) to dynamically generate workflow steps based on the user's natural language input.

High-Level Plan:

Integrate AI API: Connect your backend to your chosen AI API (OpenAI or Gemini). This will involve:

Installing the necessary SDK (e.g., openai).

Setting up authentication with the API (API keys).

Making API calls to the AI model to generate workflow steps.

Define a Data Format: Establish a consistent data format for representing workflow steps. This will make it easier to process and execute the steps later on.

Prompt Engineering: Craft effective prompts to guide the AI model in generating accurate and relevant workflow steps.

Error Handling: Implement error handling to gracefully handle cases where the AI API fails or returns unexpected results.

Validation: Implement validation to guarantee the quality and security of the responses received from the AI model.

Test and Refine: Thoroughly test the task decomposition logic and refine the prompts and parameters as needed.

Step-by-Step Implementation (Example using OpenAI):

// server/routes.ts
import express, { Request, Response } from 'express';
import { db } from './db'; // (Assuming this connected to PostgreSQL , but we will switch it to firestore to be future implmented
import { OpenAI } from 'openai'; // npm i openai
import { z } from "zod";
import { Workflow, workflows } from '../shared/schema';
import { drizzle } from 'drizzle-orm/node-postgres';

const router = express.Router();

// Initialize OpenAI (Replace with your API key and model)
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

//Zod to create a schma for the workflow object
const workflowSchema = z.object({
    task:z.string().min(3)
})

router.post('/api/workflows', async (req: Request, res: Response) => {
    try {
        // Validate the request body against the schema
        const validated = workflowSchema.safeParse(req.body)
        if (!validated.success){
            return res.status(400).json({message:"Invalid workflow object"})
        }
        const { task } = req.body;

        // 1. AI Call to generate the steps.
        const response = await openai.chat.completions.create({
            model: "gpt-3.5-turbo", // Choose your OpenAI model
            messages: [
                {
                    role: "system",
                    content: "You are a browser automation expert. Generate a JSON array of steps to accomplish the given task. Steps can include 'navigate', 'click', 'type', and 'scrape'. Provide very specific and detailed step to accomplish the given task."
                },
                {
                    role: "user",
                    content: `Task: ${task}`,
                },
            ],
        });

        // 2. Extract the steps from AI response.
        const stepsString = response.choices[0]?.message?.content;

        if (!stepsString) {
            throw new Error("No steps generated by AI.");
        }
        // Validate the json that is passed as the steops
        let steps;
        try {
            steps = JSON.parse(stepsString);
             if (!Array.isArray(steps)) {
                    throw new Error("Expected an array of steps.");
                }
        } catch (error:any) {
            console.error("Error parsing AI response:", error);
            return res.status(500).json({ message: "Error parsing AI response: " + error.message });
        }

        // 3. Validate steps (Add your validation logic here)
        // TODO: implement more robust validation as needed.
        const isValid = (steps as any[]).every(step =>
            typeof step === 'object' && step !== null &&
            'action' in step && typeof step.action === 'string'
        );

        if (!isValid) {
            return res.status(400).json({ message: "Invalid steps generated by AI." });
        }


        // 4. Save the workflow to the database.
        // TODO: IMPLEMENT SAVE FUNCTIONALITY FOR FIRE STORE

         // Save the workflow to the database.
        // TODO: IMPLEMENT SAVE FUNCTIONALITY FOR FIRE STORE
        const workflowObj = {
            task,
            steps: steps
        };

       // Assuming you have a workflows collection in Firebase
        const docRef = await db.collection('workflows').add(workflowObj);

          // Send a success response.
          res.status(201).json({ id: docRef.id, ...workflowObj });


    } catch (error: any) {
        console.error("Error creating workflow:", error);
        res.status(500).json({ message: "Error creating workflow: " + error.message });
    }
});

router.get('/api/workflows', async (req: Request, res: Response) => {
    try {
         // Fetch all workflows from Firebase
            const workflowCollection = await db.collection('workflows').get();

            // Convert the query snapshot to an array of workflow objects
            const workflows = workflowCollection.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
        res.json(workflows);
    } catch (error: any) {
        console.error("Error getting workflows:", error);
        res.status(500).json({ message: "Error getting workflows: " + error.message });
    }
});

export default router;
content_copy
download
Use code with caution.
TypeScript

Explanation and Improvements:

OpenAI Initialization: The code initializes the OpenAI API client using your API key (which should be stored in an environment variable .env). Never hardcode API keys directly in your code.

AI Prompt: The code defines a system prompt to instruct the AI model on how to generate the workflow steps.

Experiment with different prompts to see what works best. Consider adding examples of tasks and their corresponding steps (few-shot learning). For example:

"You are a browser automation expert. Generate a JSON array of steps to accomplish the given task. Steps can include 'navigate', 'click', 'type', and 'scrape'.

Example:

Task: Search for 'Python books' on Amazon.
Steps: [{\"action\": \"navigate\", \"url\": \"https://www.amazon.com\"}, {\"action\": \"type\", \"selector\": \"#twotabsearchtextbox\", \"text\": \"Python books\"}, {\"action\": \"click\", \"selector\": \"#nav-search-submit-button\"}]"
content_copy
download
Use code with caution.

AI API Call: The code makes an API call to the OpenAI chat.completions.create endpoint to generate the workflow steps. Using chat.completion gives better results as of new models by openai.

Error Handling: Wraps the whole function in a try...catch block to handle any unexpected errors, and now more specifically inside the parsing

Step Validation: It also does step validation, that every step that's generated will contain the "action" key

Firestore Integration: The original is with postgresql however you requested to implement it with fire store so i changed that for fire store, to implement your create function.

Important Notes:

API Key: Make sure to set the OPENAI_API_KEY environment variable in your Replit project or local development environment.

Firestore Rules: Implement appropriate security rules in your Firebase console to protect your Firestore data.

AI Model Selection: Consider using gpt-3.5-turbo-16k or gpt-4 for more complex tasks, but be mindful of the cost.

Asynchronous Operations: Be sure to use async and await properly when working with asynchronous operations like API calls and database interactions.

Cost Monitoring: Keep a close eye on your OpenAI and Firebase usage to avoid unexpected charges.

This improved task decomposition logic will allow you to create more dynamic and flexible workflows in your AutoFlow platform.